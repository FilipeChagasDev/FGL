# File: fglttf.py
# Author: Filipe Chagas
# Date: November-2021
# Brief: This script generates C++ code with the contents of a TTF file for 
#        using with FGL.
#
# Usage:
#    This script must be used at the terminal. With "scripts" as working directory,
#    type the command "python fglttf.py <input> <output>", where <input> is the
#    input TTF file path and <output> is the output code name (not the file name).
#    This usage of fglttf.py will generate a pair of C++ code files (header and source)
#    with a function to generate a Font object with the input TTF contents.
#
# Example:
#   '''sh
#    python fglttf.py myfold/myfont.ttf myfont
#   '''
#    This command line will generate "myfont.hpp" and "myfont.cpp". These code files
#    will contains the "myfont" function, prototyped as "Font *myfont();". "myfont"
#    will returns a pointer to a Font object.
#
# Optional parameters:
#   --fname <string> : Changes the name of the output function. Default is the same name as output code.
#   --dir <string> : Defines a root directory to header and source files. Default is '.' directory.
#   --size <int>: Defines the output FGL font size. Default is 10px.
#
# Example:
#   '''sh
#    python fglttf.py myfold/myfont.ttf myfont --dir mycodefold --fname get_myfont --size 12
#   '''
#    This command line will generate "mycodefold/myfont.hpp" and "mycodefold/myfont.cpp". These code files
#    will contains the "get_myfont" function, prototyped as "Font *get_myfont();". "get_myfont" will returns  
#    a pointer to a Font object with a 12px font similar to myfont.ttf.


from typing import *
from PIL import Image, ImageDraw, ImageFont
from datetime import datetime 
import argparse
import re
import os

today_date = datetime.today().strftime('%Y-%m-%d')

char_codes = [0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 
            0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
            0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 
            0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
            0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 
            0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
            0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 
            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x80, 
            0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8E, 
            0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 
            0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 
            0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 
            0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 
            0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 
            0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 
            0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 
            0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 
            0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 
            0xFE, 0xFF]

chars = [chr(c) for c in char_codes]

def get_char_image(char: str, font: ImageFont.ImageFont) -> Image.Image:
    w,h = font.getsize(char)
    img = Image.new('RGBA', (w,h))
    drw = ImageDraw.Draw(img)
    drw.text((0,0), char, font=font)
    return img

def get_glyph(tab: int, char: str, font: ImageFont.ImageFont) -> Tuple[str, str]:
    img = get_char_image(char, font)
    text = '\t'*tab + f'Glyph *glyph{ord(char)} = new Glyph({img.width}, {img.height});\n'

    for i in range(img.width):
        for j in range(img.height):
            value = img.getpixel((i,j))[3]
            text += '\t'*tab + f'glyph{ord(char)}->setPixel({i}, {j}, {value});\n'

    return f'glyph{ord(char)}', text

def make_font_function(fname: str, font: ImageFont.ImageFont) -> str:
    text = (
        f'Font *{fname}()\n'
        '{\n'
        '\tFont *myfont = new Font();\n\n'
    )

    for char in chars:
        print(f'Generating glyph for \'{char}\'')
        var_name, glyph_text = get_glyph(1, char, font)
        text += glyph_text
        text += f'\tmyfont->setGlyph({hex(ord(char))}, {var_name});\n\n'

    text += '\treturn myfont;\n}\n'
    return text

def make_header_text(name: str, fname: str) -> str:
    text = (
        '/* -- F Graphics Library --\n'
        ' * Code generated by the fglttf.py script\n'
        f' * Font name: {name}\n'
        f' * Generation date (Y-M-D): {today_date}\n'
        ' */\n'
        '\n'
        f'#ifndef {name.upper()}_HPP\n'
        f'#define {name.upper()}_HPP\n'
        '#include <font.hpp>\n'
        '#include <glyph.hpp>\n'
        '\n'
        f'Font *{fname}();\n'
        '\n'
        '#endif'
    )
    return text

def make_source_text(name: str, fname: str, font: ImageFont.ImageFont):
    text = (
        '/* -- F Graphics Library --\n'
        ' * Code generated by the fglttf.py script\n'
        f' * Font name: {name}\n'
        f' * Generation date (Y-M-D): {today_date}\n'
        ' */\n'
        '\n'
        f'#include \"{name}.hpp\"\n'
        '\n'
    )
    text += make_font_function(fname, font)
    return text 


def check_cpp_identifier(txt: str) -> bool:
    matching = re.match('([a-zA-Z]|_)([a-zA-Z]|[0-9]|_)*', txt)
    if matching != None:
        return matching.span() == (0, len(txt))
    else:
        return False

def save_to_file(file_name: str, text: str):
    f = open(file_name, 'w')
    f.write(text)
    f.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generates a C++ code with the contents af an image file to using with FGL.')
    parser.add_argument('input_font', type=str, help='Input TTF file path.')
    parser.add_argument('output_name', type=str, help='Name for the generated code (without path or extensions).')
    parser.add_argument('--dir', type=str, help='Root directory for the generated files.')
    parser.add_argument('--fname', type=str, help='Name for the generated function (if this argument is not set, output_name is used as function name).')
    parser.add_argument('--size', type=int, help='Font size (10 by default)')
    
    args = parser.parse_args()

    #Check output directory name
    dir = args.dir if args.dir != None else '.'

    if not os.path.exists(dir):
        print(f'No such file or directory: {dir}')
        exit()

    if not os.path.isdir(dir):
        print(f'Path is not a dir: {dir}')
        exit()

    #Load font file
    if not os.path.exists(args.input_font):
        print('No such file or directory:', args.input_font)
        exit()
    
    if not os.path.isfile(args.input_font):
        print(args.input_font, 'is not a file')
        exit()

    try:
        font = ImageFont.truetype(args.input_font, size= args.size if args.size != None else 10)
    except:
        print(f'Cannot load {args.input_font} (size={args.size if args.size != None else 10}) as truetype font')
        exit()

    #Output name
    if not check_cpp_identifier(args.output_name):
        print('Invalid output name.')
        print('output_name must have only numbers (not as first character), letters and underscores.')
        exit()
    
    #Function name
    function_name = args.fname if args.fname != None else args.output_name

    if not check_cpp_identifier(function_name):
        print('Invalid fname.')
        print('fname must have only numbers (not as first character), letters and underscores.')
        exit()

    #Generate code
    htxt = make_header_text(args.output_name, function_name)
    stxt = make_source_text(args.output_name, function_name, font)
   
    save_to_file(os.path.join(dir, args.output_name + '.hpp'), htxt)
    save_to_file(os.path.join(dir, args.output_name + '.cpp'), stxt)
