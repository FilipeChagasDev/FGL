/*
 * canvas.cpp
 *
 *  Created on: 22 de out de 2021
 *      Author: Filipe Chagas
 */

#include <pencil.hpp>
#include <math.h>
#include <assert.h>
#include <base/ccw_sort.hpp>
#include <base/array_search.hpp>
#include <base/list.hpp>

#define ABS(v) (((v) >= 0) ? (v) : -(v))
#define PI 3.14159265359

#ifndef EXCLUDE_DEFAULT_FONT
const uint8_t default_font_data[] = {
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
  0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
  0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
  0x18, 0x3C, 0x7E, 0x3C, 0x18,
  0x1C, 0x57, 0x7D, 0x57, 0x1C,
  0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
  0x00, 0x18, 0x3C, 0x18, 0x00,
  0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
  0x00, 0x18, 0x24, 0x18, 0x00,
  0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
  0x30, 0x48, 0x3A, 0x06, 0x0E,
  0x26, 0x29, 0x79, 0x29, 0x26,
  0x40, 0x7F, 0x05, 0x05, 0x07,
  0x40, 0x7F, 0x05, 0x25, 0x3F,
  0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
  0x7F, 0x3E, 0x1C, 0x1C, 0x08,
  0x08, 0x1C, 0x1C, 0x3E, 0x7F,
  0x14, 0x22, 0x7F, 0x22, 0x14,
  0x5F, 0x5F, 0x00, 0x5F, 0x5F,
  0x06, 0x09, 0x7F, 0x01, 0x7F,
  0x00, 0x66, 0x89, 0x95, 0x6A,
  0x60, 0x60, 0x60, 0x60, 0x60,
  0x94, 0xA2, 0xFF, 0xA2, 0x94,
  0x08, 0x04, 0x7E, 0x04, 0x08,
  0x10, 0x20, 0x7E, 0x20, 0x10,
  0x08, 0x08, 0x2A, 0x1C, 0x08,
  0x08, 0x1C, 0x2A, 0x08, 0x08,
  0x1E, 0x10, 0x10, 0x10, 0x10,
  0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
  0x30, 0x38, 0x3E, 0x38, 0x30,
  0x06, 0x0E, 0x3E, 0x0E, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x5F, 0x00, 0x00,
  0x00, 0x07, 0x00, 0x07, 0x00,
  0x14, 0x7F, 0x14, 0x7F, 0x14,
  0x24, 0x2A, 0x7F, 0x2A, 0x12,
  0x23, 0x13, 0x08, 0x64, 0x62,
  0x36, 0x49, 0x56, 0x20, 0x50,
  0x00, 0x08, 0x07, 0x03, 0x00,
  0x00, 0x1C, 0x22, 0x41, 0x00,
  0x00, 0x41, 0x22, 0x1C, 0x00,
  0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
  0x08, 0x08, 0x3E, 0x08, 0x08,
  0x00, 0x80, 0x70, 0x30, 0x00,
  0x08, 0x08, 0x08, 0x08, 0x08,
  0x00, 0x00, 0x60, 0x60, 0x00,
  0x20, 0x10, 0x08, 0x04, 0x02,
  0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
  0x00, 0x42, 0x7F, 0x40, 0x00, // 1
  0x72, 0x49, 0x49, 0x49, 0x46, // 2
  0x21, 0x41, 0x49, 0x4D, 0x33, // 3
  0x18, 0x14, 0x12, 0x7F, 0x10, // 4
  0x27, 0x45, 0x45, 0x45, 0x39, // 5
  0x3C, 0x4A, 0x49, 0x49, 0x31, // 6
  0x41, 0x21, 0x11, 0x09, 0x07, // 7
  0x36, 0x49, 0x49, 0x49, 0x36, // 8
  0x46, 0x49, 0x49, 0x29, 0x1E, // 9
  0x00, 0x00, 0x14, 0x00, 0x00,
  0x00, 0x40, 0x34, 0x00, 0x00,
  0x00, 0x08, 0x14, 0x22, 0x41,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x00, 0x41, 0x22, 0x14, 0x08,
  0x02, 0x01, 0x59, 0x09, 0x06,
  0x3E, 0x41, 0x5D, 0x59, 0x4E,
  0x7C, 0x12, 0x11, 0x12, 0x7C, // A
  0x7F, 0x49, 0x49, 0x49, 0x36, // B
  0x3E, 0x41, 0x41, 0x41, 0x22, // C
  0x7F, 0x41, 0x41, 0x41, 0x3E, // D
  0x7F, 0x49, 0x49, 0x49, 0x41, // E
  0x7F, 0x09, 0x09, 0x09, 0x01, // F
  0x3E, 0x41, 0x41, 0x51, 0x73, // G
  0x7F, 0x08, 0x08, 0x08, 0x7F, // H
  0x00, 0x41, 0x7F, 0x41, 0x00, // I
  0x20, 0x40, 0x41, 0x3F, 0x01, // J
  0x7F, 0x08, 0x14, 0x22, 0x41, // K
  0x7F, 0x40, 0x40, 0x40, 0x40, // L
  0x7F, 0x02, 0x1C, 0x02, 0x7F, // M
  0x7F, 0x04, 0x08, 0x10, 0x7F, // N
  0x3E, 0x41, 0x41, 0x41, 0x3E, // O
  0x7F, 0x09, 0x09, 0x09, 0x06, // P
  0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
  0x7F, 0x09, 0x19, 0x29, 0x46, // R
  0x26, 0x49, 0x49, 0x49, 0x32, // S
  0x03, 0x01, 0x7F, 0x01, 0x03, // T
  0x3F, 0x40, 0x40, 0x40, 0x3F, // U
  0x1F, 0x20, 0x40, 0x20, 0x1F, // V
  0x3F, 0x40, 0x38, 0x40, 0x3F, // W
  0x63, 0x14, 0x08, 0x14, 0x63, // X
  0x03, 0x04, 0x78, 0x04, 0x03, // Y
  0x61, 0x59, 0x49, 0x4D, 0x43, // Z
  0x00, 0x7F, 0x41, 0x41, 0x41,
  0x02, 0x04, 0x08, 0x10, 0x20,
  0x00, 0x41, 0x41, 0x41, 0x7F,
  0x04, 0x02, 0x01, 0x02, 0x04,
  0x40, 0x40, 0x40, 0x40, 0x40,
  0x00, 0x03, 0x07, 0x08, 0x00,
  0x20, 0x54, 0x54, 0x78, 0x40, // a
  0x7F, 0x28, 0x44, 0x44, 0x38, // b
  0x38, 0x44, 0x44, 0x44, 0x28, // c
  0x38, 0x44, 0x44, 0x28, 0x7F, // d
  0x38, 0x54, 0x54, 0x54, 0x18, // e
  0x00, 0x08, 0x7E, 0x09, 0x02, // f
  0x18, 0xA4, 0xA4, 0x9C, 0x78, // g
  0x7F, 0x08, 0x04, 0x04, 0x78, // h
  0x00, 0x44, 0x7D, 0x40, 0x00, // i
  0x20, 0x40, 0x40, 0x3D, 0x00, // j
  0x7F, 0x10, 0x28, 0x44, 0x00, // k
  0x00, 0x41, 0x7F, 0x40, 0x00, // l
  0x7C, 0x04, 0x78, 0x04, 0x78, // m
  0x7C, 0x08, 0x04, 0x04, 0x78, // n
  0x38, 0x44, 0x44, 0x44, 0x38, // o
  0xFC, 0x18, 0x24, 0x24, 0x18, // p
  0x18, 0x24, 0x24, 0x18, 0xFC, // q
  0x7C, 0x08, 0x04, 0x04, 0x08, // r
  0x48, 0x54, 0x54, 0x54, 0x24, // s
  0x04, 0x04, 0x3F, 0x44, 0x24, // t
  0x3C, 0x40, 0x40, 0x20, 0x7C, // u
  0x1C, 0x20, 0x40, 0x20, 0x1C, // v
  0x3C, 0x40, 0x30, 0x40, 0x3C, // w
  0x44, 0x28, 0x10, 0x28, 0x44, // x
  0x4C, 0x90, 0x90, 0x90, 0x7C, // y
  0x44, 0x64, 0x54, 0x4C, 0x44, // z
  0x00, 0x08, 0x36, 0x41, 0x00,
  0x00, 0x00, 0x77, 0x00, 0x00,
  0x00, 0x41, 0x36, 0x08, 0x00,
  0x02, 0x01, 0x02, 0x04, 0x02,
  0x3C, 0x26, 0x23, 0x26, 0x3C,
  0x1E, 0xA1, 0xA1, 0x61, 0x12,
  0x3A, 0x40, 0x40, 0x20, 0x7A,
  0x38, 0x54, 0x54, 0x55, 0x59,
  0x21, 0x55, 0x55, 0x79, 0x41,
  0x21, 0x54, 0x54, 0x78, 0x41,
  0x21, 0x55, 0x54, 0x78, 0x40,
  0x20, 0x54, 0x55, 0x79, 0x40,
  0x0C, 0x1E, 0x52, 0x72, 0x12,
  0x39, 0x55, 0x55, 0x55, 0x59,
  0x39, 0x54, 0x54, 0x54, 0x59,
  0x39, 0x55, 0x54, 0x54, 0x58,
  0x00, 0x00, 0x45, 0x7C, 0x41,
  0x00, 0x02, 0x45, 0x7D, 0x42,
  0x00, 0x01, 0x45, 0x7C, 0x40,
  0xF0, 0x29, 0x24, 0x29, 0xF0,
  0xF0, 0x28, 0x25, 0x28, 0xF0,
  0x7C, 0x54, 0x55, 0x45, 0x00,
  0x20, 0x54, 0x54, 0x7C, 0x54,
  0x7C, 0x0A, 0x09, 0x7F, 0x49,
  0x32, 0x49, 0x49, 0x49, 0x32,
  0x32, 0x48, 0x48, 0x48, 0x32,
  0x32, 0x4A, 0x48, 0x48, 0x30,
  0x3A, 0x41, 0x41, 0x21, 0x7A,
  0x3A, 0x42, 0x40, 0x20, 0x78,
  0x00, 0x9D, 0xA0, 0xA0, 0x7D,
  0x39, 0x44, 0x44, 0x44, 0x39,
  0x3D, 0x40, 0x40, 0x40, 0x3D,
  0x3C, 0x24, 0xFF, 0x24, 0x24,
  0x48, 0x7E, 0x49, 0x43, 0x66,
  0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
  0xFF, 0x09, 0x29, 0xF6, 0x20,
  0xC0, 0x88, 0x7E, 0x09, 0x03,
  0x20, 0x54, 0x54, 0x79, 0x41,
  0x00, 0x00, 0x44, 0x7D, 0x41,
  0x30, 0x48, 0x48, 0x4A, 0x32,
  0x38, 0x40, 0x40, 0x22, 0x7A,
  0x00, 0x7A, 0x0A, 0x0A, 0x72,
  0x7D, 0x0D, 0x19, 0x31, 0x7D,
  0x26, 0x29, 0x29, 0x2F, 0x28,
  0x26, 0x29, 0x29, 0x29, 0x26,
  0x30, 0x48, 0x4D, 0x40, 0x20,
  0x38, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x38,
  0x2F, 0x10, 0xC8, 0xAC, 0xBA,
  0x2F, 0x10, 0x28, 0x34, 0xFA,
  0x00, 0x00, 0x7B, 0x00, 0x00,
  0x08, 0x14, 0x2A, 0x14, 0x22,
  0x22, 0x14, 0x2A, 0x14, 0x08,
  0xAA, 0x00, 0x55, 0x00, 0xAA,
  0xAA, 0x55, 0xAA, 0x55, 0xAA,
  0x00, 0x00, 0x00, 0xFF, 0x00,
  0x10, 0x10, 0x10, 0xFF, 0x00,
  0x14, 0x14, 0x14, 0xFF, 0x00,
  0x10, 0x10, 0xFF, 0x00, 0xFF,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x14, 0x14, 0x14, 0xFC, 0x00,
  0x14, 0x14, 0xF7, 0x00, 0xFF,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x14, 0x14, 0xF4, 0x04, 0xFC,
  0x14, 0x14, 0x17, 0x10, 0x1F,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0x1F, 0x00,
  0x10, 0x10, 0x10, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0xF0, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x10,
  0x10, 0x10, 0x10, 0x10, 0x10,
  0x10, 0x10, 0x10, 0xFF, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x14,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x00, 0x00, 0x1F, 0x10, 0x17,
  0x00, 0x00, 0xFC, 0x04, 0xF4,
  0x14, 0x14, 0x17, 0x10, 0x17,
  0x14, 0x14, 0xF4, 0x04, 0xF4,
  0x00, 0x00, 0xFF, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x14, 0x14, 0xF7, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x17, 0x14,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0xF4, 0x14,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x00, 0x00, 0x1F, 0x10, 0x1F,
  0x00, 0x00, 0x00, 0x1F, 0x14,
  0x00, 0x00, 0x00, 0xFC, 0x14,
  0x00, 0x00, 0xF0, 0x10, 0xF0,
  0x10, 0x10, 0xFF, 0x10, 0xFF,
  0x14, 0x14, 0x14, 0xFF, 0x14,
  0x10, 0x10, 0x10, 0x1F, 0x00,
  0x00, 0x00, 0x00, 0xF0, 0x10,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xFF, 0xFF, 0xFF, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xFF,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
  0x38, 0x44, 0x44, 0x38, 0x44,
  0x7C, 0x2A, 0x2A, 0x3E, 0x14,
  0x7E, 0x02, 0x02, 0x06, 0x06,
  0x02, 0x7E, 0x02, 0x7E, 0x02,
  0x63, 0x55, 0x49, 0x41, 0x63,
  0x38, 0x44, 0x44, 0x3C, 0x04,
  0x40, 0x7E, 0x20, 0x1E, 0x20,
  0x06, 0x02, 0x7E, 0x02, 0x02,
  0x99, 0xA5, 0xE7, 0xA5, 0x99,
  0x1C, 0x2A, 0x49, 0x2A, 0x1C,
  0x4C, 0x72, 0x01, 0x72, 0x4C,
  0x30, 0x4A, 0x4D, 0x4D, 0x30,
  0x30, 0x48, 0x78, 0x48, 0x30,
  0xBC, 0x62, 0x5A, 0x46, 0x3D,
  0x3E, 0x49, 0x49, 0x49, 0x00,
  0x7E, 0x01, 0x01, 0x01, 0x7E,
  0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
  0x44, 0x44, 0x5F, 0x44, 0x44,
  0x40, 0x51, 0x4A, 0x44, 0x40,
  0x40, 0x44, 0x4A, 0x51, 0x40,
  0x00, 0x00, 0xFF, 0x01, 0x03,
  0xE0, 0x80, 0xFF, 0x00, 0x00,
  0x08, 0x08, 0x6B, 0x6B, 0x08,
  0x36, 0x12, 0x36, 0x24, 0x36,
  0x06, 0x0F, 0x09, 0x0F, 0x06,
  0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0x00, 0x10, 0x10, 0x00,
  0x30, 0x40, 0xFF, 0x01, 0x01,
  0x00, 0x1F, 0x01, 0x01, 0x1E,
  0x00, 0x19, 0x1D, 0x17, 0x12,
  0x00, 0x3C, 0x3C, 0x3C, 0x3C,
  0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif

Pencil::Pencil(Display &display)
{
    this->display = &display;
    this->w = display.getWidth();
    this->h = display.getHeight();
}

Pencil::~Pencil()
{

}

void Pencil::drawPixel(float x, float y, Color color)
{
    this->display->drawPixel(roundf(x), roundf(y), color.r, color.g, color.b);
}

void Pencil::drawLine(float x1, float y1, float x2, float y2, Color color)
{
    float a = (y2-y1)/(x2-x1);

    if(ABS(a) < 1)
    {
        float bx = (x1 > x2) ? x1 : x2; //bigger x
        float sx = (x1 > x2) ? x2 : x1; //smaller x
        float b = y1 - a*x1;
        for(float x = floorf(sx); x <= bx; x+=1)
        {
            this->drawPixel(x, a*x+b, color);
        }
    }
    else //ABS(A) >= 1
    {
        float by = (y1 > y2) ? y1 : y2; //bigger y
        float sy = (y1 > y2) ? y2 : y1; //smaller y
        float ai = (x2-x1)/(y2-y1);
        float bi = x1 - ai*y1;
        for(float y = floorf(sy); y <= by; y+=1)
        {
            this->drawPixel(ai*y+bi, y, color);
        }
    }

}

void Pencil::drawRectangle(float x, float y, float w, float h, Color color)
{
    assert(w >= 0);
    assert(h >= 0);

    if(w > 0 and h > 0)
    {
        //Horizontal lines
        this->drawLine(x, y, x+w, y, color);
        this->drawLine(x, y+h, x+w, y+h, color);

        //Vertical lines
        this->drawLine(x, y, x, y+h, color);
        this->drawLine(x+w, y, x+w, y+h, color);
    }
}

void Pencil::drawCircle(float x, float y, float radius, Color color, uint32_t vertices)
{
    assert(radius >= 0);
    assert(vertices > 2);

    if(radius > 0)
    {
        float step = 2*PI/(float)vertices;
        float _x_prev = x + radius;
        float _y_prev = y;

        for(float theta = step; theta < 2*PI; theta += step)
        {
            float _x = x + radius*cosf(theta);
            float _y = y + radius*sinf(theta);
            this->drawLine(_x_prev, _y_prev, _x, _y, color);
            _x_prev = _x;
            _y_prev = _y;
        }

        float _x = x + radius*cosf(2*PI);
        float _y = y + radius*sinf(2*PI);
        this->drawLine(_x_prev, _y_prev, _x, _y, color);
    }
}

void Pencil::drawEllipse(float x, float y, float w, float h, Color color, uint32_t vertices)
{
    assert(w >= 0);
    assert(h >= 0);
    assert(vertices > 2);

    if(w > 0 and h > 0)
    {
        float step = 2*PI/(float)vertices;
        float xr = w/2; //x-axis radius
        float yr = h/2; //y-axis radius
        float _x_prev = x + xr;
        float _y_prev = y;

        for(float theta = step; theta < 2*PI; theta += step)
        {
            float _x = x + xr*cosf(theta);
            float _y = y + yr*sinf(theta);
            this->drawLine(_x_prev, _y_prev, _x, _y, color);
            _x_prev = _x;
            _y_prev = _y;
        }

        float _x = x + xr*cosf(2*PI);
        float _y = y + yr*sinf(2*PI);
        this->drawLine(_x_prev, _y_prev, _x, _y, color);
    }
}

void Pencil::drawArc(float x, float y, float theta1, float theta2, float radius, Color color, uint32_t vertices)
{
    assert(radius > 0);
    assert(vertices > 2);

    if(radius > 0 and ABS(theta2-theta1) > 0)
    {
        float step = ABS(theta2-theta1)/(float)vertices;

        float _x_prev = x + radius*cosf(theta1);
        float _y_prev = y + radius*sinf(theta1);

        if(theta2 > theta1) //counter-clockwise rotation
        {
            for(float theta = theta1+step; theta < theta2; theta += step)
            {
                float _x = x + radius*cosf(theta);
                float _y = y + radius*sinf(theta);
                this->drawLine(_x_prev, _y_prev, _x, _y, color);
                _x_prev = _x;
                _y_prev = _y;
            }
        }
        else //clockwise rotation
        {
            for(float theta = theta1-step; theta > theta2; theta -= step)
            {
                float _x = x + radius*cosf(theta);
                float _y = y + radius*sinf(theta);
                this->drawLine(_x_prev, _y_prev, _x, _y, color);
                _x_prev = _x;
                _y_prev = _y;
            }
        }

        float _x = x + radius*cos(theta2);
        float _y = y + radius*sin(theta2);
        this->drawLine(_x_prev, _y_prev, _x, _y, color);
    }
}

void Pencil::drawRoundedRectangle(float x, float y, float w, float h, float radius, Color color, uint32_t edge_vertices)
{
    assert(w >= 0);
    assert(h >= 0);
    assert(radius >= 0);
    assert(edge_vertices > 2);

    if(w > 0 and h > 0 and radius > 0)
    {
        //Horizontal lines
        this->drawLine(x+radius, y, x+w-radius, y, color); //Top
        this->drawLine(x+radius, y+h, x+w-radius, y+h, color); //Bottom

        //Vertical lines
        this->drawLine(x, y+radius, x, y+h-radius, color); //Left
        this->drawLine(x+w, y+radius, x+w, y+h-radius, color); //Right

        //Edges
        this->drawArc(x+radius, y+radius, PI, PI+PI/2, radius, color, edge_vertices); //Left-top
        this->drawArc(x+radius, y+h-radius, PI/2, PI, radius, color, edge_vertices); //Left-bottom
        this->drawArc(x+w-radius, y+radius, PI+PI/2, 2*PI, radius, color, edge_vertices); //Right-top
        this->drawArc(x+w-radius, y+h-radius, 0, PI/2, radius, color, edge_vertices); //Right-bottom
    }
}

void Pencil::drawPolygon(float *x_array, float *y_array, uint32_t len, Color color)
{
    assert(len > 2);

    float min_x = min_float(x_array, len);
    float min_y = min_float(y_array, len);
    float max_x = max_float(x_array, len);
    float max_y = max_float(y_array, len);

    ccw_selection_sort(x_array, y_array, len); //sort points counter clockwise

    for(int i = 1; i < len; i++)
    {
        this->drawLine(x_array[i-1], y_array[i-1], x_array[i], y_array[i], color);
    }

    this->drawLine(x_array[len-1], y_array[len-1], x_array[0], y_array[0], color);
}

void Pencil::drawGlyph(float x, float y, Glyph &glyph, Color color)
{
    for(int i = 0; i < glyph.w; i++)
    {
        for(int j = 0; j < glyph.h; j++)
        {
            float v = (float)glyph.getPixel(i,j)/255.0;
            this->drawPixel(i+x,j+y, Color(v*color.a, color.r, color.g, color.b));
        }
    }
}

Rectangle Pencil::drawChar(float x, float y, char c, Font &font, Color color)
{ 
    Glyph *glyph = font.getGlyph(c);
    this->drawGlyph(x, y, *glyph, color);

    Rectangle affected_area;
    affected_area.x = x;
    affected_area.y = y;
    affected_area.width = glyph->w;
    affected_area.height = glyph->h;
    return affected_area;
}

#ifndef EXCLUDE_DEFAULT_FONT
Rectangle Pencil::drawChar(float x, float y, char c, Color color)
{
    for(int i = 0; i < 5; i++)
    {
        uint8_t line = default_font_data[c*5 + i];
        for(int j = 0; j < 8; j++)
        {
            if((line >> j) & 0x1)
            {
                this->drawPixel(x+i, y+j, color);
            }
        }
    }

    Rectangle rect;
    rect.x = x;
    rect.y = y;
    rect.width = 8;
    rect.height = 5;
    return rect;
}
#endif

Rectangle Pencil::drawText(float x, float y, const char* text, Font &font, Color color, float h_spacing, float v_spacing)
{
    assert(text != nullptr);

    float x_position = x;
    float y_position = y;
    float y_line_bottom = y_position;

    Rectangle affected_area;
    affected_area.x = x;
    affected_area.y = y;
    affected_area.width = x;
    affected_area.height = y;

    for(int i = 0; text[i] != '\0'; i++)
    {
        if(text[i] != '\n' and text[i] != '\t')
        {
            Glyph *glyph = font.getGlyph(text[i]);
            this->drawGlyph(x_position, y_position, *glyph, color);
            x_position += glyph->w + h_spacing;

            if(y_line_bottom <  y_position + glyph->h) y_line_bottom = y_position + glyph->h;
        }
        else if(text[i] == '\n')
        {
            y_position = y_line_bottom + v_spacing;
            x_position = x;
        }
        else if(text[i] == '\t')
        {
             x_position += font.getGlyph(' ')->w*4;
        }

        if(affected_area.width < x_position - x) affected_area.width = x_position - x;
        if(affected_area.height < y_position - y) affected_area.height = y_position - y;
    }

    return affected_area;
}

#ifndef EXCLUDE_DEFAULT_FONT
Rectangle Pencil::drawText(float x, float y, const char *text, Color color, float h_spacing, float v_spacing)
{
    assert(text != nullptr);

    float x_position = x;
    float y_position = y;
    float y_line_bottom = y_position;

    Rectangle affected_area;
    affected_area.x = x;
    affected_area.y = y;
    affected_area.width = x;
    affected_area.height = y;

    for(int i = 0; text[i] != '\0'; i++)
    {
        if(text[i] != '\n' and text[i] != '\t')
        {
            Rectangle caa = this->drawChar(x_position, y_position, text[i], color);
            x_position += caa.width + h_spacing;

            if(y_line_bottom <  y_position + caa.height) y_line_bottom = y_position + caa.height;
        }
        else if(text[i] == '\n')
        {
            y_position = y_line_bottom + v_spacing;
            x_position = x;
        }
        else if(text[i] == '\t')
        {
             x_position += 8*4;
        }

        if(affected_area.width < x_position - x) affected_area.width = x_position - x;
        if(affected_area.height < y_position - y) affected_area.height = y_position - y;
    }

    return affected_area;
}
#endif

void Pencil::drawImage(float x, float y, Image &image)
{
    assert(x >= 0);
    assert(y >= 0);

    for(uint32_t i = 0; i < image.getWidth(); i++)
    {
        for(uint32_t j = 0; j < image.getHeight(); j++)
        {
            this->drawPixel(floorf(x)+i, floorf(y)+j, image.getPixel(i, j));
        }
    }
}

void Pencil::fillRectangle(float x, float y, float w, float h, Color color)
{
    assert(w >= 0);
    assert(h >= 0);

    int i_lim = (int)floorf(x+w);
    int j_lim = (int)floorf(y+h);

    for(int i = ceilf(x); i < i_lim; i++)
    {
        for(int j = ceilf(y); j < j_lim; j++)
        {
            this->drawPixel(i, j, color);
        }
    }

    this->drawRectangle(x, y, w, h, color); //Border
}

void Pencil::fillCircle(float x, float y, float radius, Color color)
{
    assert(radius >= 0);

    if(radius > 0)
    {
        float round_radius = roundf(radius);
        for(float i = -round_radius; i <= round_radius; i += 1)
        {
            float k = radius*radius - i*i;
            if(k >= 0)
            {
                float j = sqrtf(k);
                this->drawLine(x+i, y-j, x+i, y+j, color);
            }
        }
    }
}

void Pencil::fillEllipse(float x, float y, float w, float h, Color color)
{
    assert(w >= 0);
    assert(h >= 0);

    if(w > 0 and h > 0)
    {
        float round_radius = roundf(w/2);
        for(float i = -round_radius; i <= round_radius; i += 1)
        {
            float k = w*w - 4*i*i;
            if(k >= 0)
            {
                float j = h*sqrtf(k)/(2*w);
                this->drawLine(x+i, y-j, x+i, y+j, color);
            }
        }
    }
}

void Pencil::fillPolygon(float *x_array, float *y_array, uint32_t len, Color color)
{
    assert(len > 2);

    float min_x = min_float(x_array, len);
    float min_y = min_float(y_array, len);
    float max_x = max_float(x_array, len);
    float max_y = max_float(y_array, len);

    ccw_selection_sort(x_array, y_array, len); //sort points counter clockwise

    for(int i = floorf(min_x); i < ceilf(max_x); i++)
    {
        for(int j = floorf(min_y); j < ceilf(max_y); j++)
        {
            bool inside = true;

            for(int k = 1; k < len; k++)
            {
                float f = (x_array[k]-x_array[k-1])*j + (y_array[k-1]-y_array[k])*i + (x_array[k-1]*y_array[k] - x_array[k]*y_array[k-1]);
                inside = inside and (f >= 0);
            }

            float f = (x_array[0]-x_array[len-1])*j + (y_array[len-1]-y_array[0])*i + (x_array[len-1]*y_array[0] - x_array[0]*y_array[len-1]);
            inside = inside and (f >= 0);
            if(inside) this->drawPixel(i, j, color);
        }
    }
}


void Pencil::fillSector(float x, float y, float theta1, float theta2, float radius, Color color, uint32_t vertices)
{
    assert(radius >= 0);
    assert(vertices > 2);

    if(radius > 0 and ABS(theta2-theta1) > 0)
    {
        List<float> x_list;
        List<float> y_list;
        x_list.pushEnd(x);
        y_list.pushEnd(y);

        float step = ABS(theta2-theta1)/(float)vertices;

        if(theta2 > theta1) //counter-clockwise rotation
        {
            for(float theta = theta1; theta < theta2; theta += step)
            {
                float _x = x + radius*cosf(theta);
                float _y = y + radius*sinf(theta);
                x_list.pushEnd(_x);
                y_list.pushEnd(_y);

                if(ABS(theta-theta1) >= PI/2) //For each PI/2 rotation, paint the half-sector, clear the lists and continue from then on
                {
                    if(x_list.getLen() > 2)
                        this->fillPolygon(x_list.getArray(), y_list.getArray(), x_list.getLen(), color);
                    x_list.clear();
                    y_list.clear();
                    x_list.pushEnd(x);
                    y_list.pushEnd(y);
                    x_list.pushEnd(_x);
                    y_list.pushEnd(_y);
                }
            }
        }
        else //clockwise rotation
        {
            for(float theta = theta1; theta > theta2; theta -= step)
            {
                float _x = x + radius*cosf(theta);
                float _y = y + radius*sinf(theta);
                x_list.pushEnd(_x);
                y_list.pushEnd(_y);

                if(ABS(theta-theta1) >= PI/2) //For each PI/2 rotation, paint the half-sector, clear the lists and continue from then on
                {
                    if(x_list.getLen() > 2)
                        this->fillPolygon(x_list.getArray(), y_list.getArray(), x_list.getLen(), color);
                    x_list.clear();
                    y_list.clear();
                    x_list.pushEnd(x);
                    y_list.pushEnd(y);
                    x_list.pushEnd(_x);
                    y_list.pushEnd(_y);
                }
            }
        }

        float _x = x + radius*cos(theta2);
        float _y = y + radius*sin(theta2);
        x_list.pushEnd(_x);
        y_list.pushEnd(_y);

        if(x_list.getLen() > 2)
            this->fillPolygon(x_list.getArray(), y_list.getArray(), x_list.getLen(), color);

        this->drawArc(x, y, theta1, theta2, radius, color, vertices); //Border
    }
}

void Pencil::fillRoundedRectangle(float x, float y, float w, float h, float radius, Color color, uint32_t edge_vertices)
{
    assert(w >= 0);
    assert(h >= 0);
    assert(radius >= 0);
    assert(edge_vertices > 2);

    if(w > 0 and h > 0 and radius > 0)
    {
        this->fillRectangle(x, y+radius, radius, h-2*radius, color); //Left rectangle
        this->fillRectangle(x+w-radius, y+radius, radius, h-2*radius, color); //Right rectangle
        this->fillRectangle(x+radius, y, w-2*radius, h, color); //Central rectangle

        //Edges
        //this->fillSector(x+radius, y+radius, PI, PI+PI/2, radius, color); //Left-top
        //this->fillSector(x+radius, y+h-radius, PI/2, PI, radius, color); //Left-bottom
        //this->fillSector(x+w-radius, y+radius, PI+PI/2, 2*PI, radius, color); //Right-top
        //this->fillSector(x+w-radius, y+h-radius, 0, PI/2, radius, color); //Right-bottom
        this->fillCircle(x+radius, y+radius, radius, color); //Left-top
        this->fillCircle(x+radius, y+h-radius, radius, color); //Left-bottom
        this->fillCircle(x+w-radius, y+radius, radius, color); //Right-top
        this->fillCircle(x+w-radius, y+h-radius, radius, color); //Right-bottom

        this->drawRoundedRectangle(x, y, w, h, radius, color, edge_vertices);
    }
}
